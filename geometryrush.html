<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Geometry Dash | OG Edition</title>
<meta name="description" content="OG Geometry Dash â€” neon cube, rhythmic jumps, endless levels." />
<style>
  :root{
    --bg:#0d0d0d;
    --neon:#00ff88;
    --neon-2:#00ffcc;
    --panel:#111;
  }
  html,body{height:100%;margin:0;font-family:Poppins,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{
    display:flex;
    align-items:center;
    justify-content:center;
    background:var(--bg);
    color:var(--neon);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    height:100vh;
    overflow:hidden;
  }
  .container{
    display:flex;
    gap:18px;
    align-items:flex-start;
  }
  .sidebar, .ads{
    width:200px;
    height:360px;
    background:var(--panel);
    border:2px solid #00ff66;
    border-radius:10px;
    padding:12px;
    box-shadow:0 0 18px rgba(0,255,102,0.15);
  }
  .sidebar h2, .ads h2{margin:0 0 8px;font-size:1rem;text-align:center;color:var(--neon);}
  .funfact{font-size:0.9rem;color:#cdd;line-height:1.3; text-align:justify; animation:fade 1s;}
  @keyframes fade{from{opacity:0}to{opacity:1}}
  .game-section{display:flex;flex-direction:column;align-items:center;}
  h1{margin:8px 0;color:var(--neon);text-shadow:0 0 14px rgba(0,255,136,0.18);font-size:1.15rem}
  canvas{border-radius:10px;border:3px solid var(--neon);box-shadow:0 0 28px rgba(0,255,136,0.12);background:linear-gradient(180deg,#0b0b0b,#111);}
  #scoreboard{margin-top:10px;font-size:1rem}
  #restartBtn{margin-top:10px;background:var(--neon);color:var(--bg);border:none;padding:8px 16px;border-radius:8px;font-weight:700;cursor:pointer;transition:all .18s}
  #restartBtn:hover{transform:translateY(-2px);filter:brightness(.95)}
  .small{font-size:0.85rem;color:#bfeec7}
</style>
</head>
<body>
<div class="container">
  <div class="sidebar">
    <h2>ðŸ§  Fun Facts</h2>
    <p class="funfact" id="funFact">Loading fun fact...</p>
  </div>

  <div class="game-section">
    <h1>â¬› Geometry Dash â€” OG Edition</h1>
    <canvas id="game" width="760" height="360"></canvas>
    <div id="scoreboard">Distance: <span id="score">0</span> | Best: <span id="high">0</span></div>
    <button id="restartBtn">Restart</button>
    <div class="small">Controls: Space / â†‘ / Click to jump</div>
  </div>

  <div class="ads">
    <h2>ðŸ“¢ Ads Space</h2>
    <p style="text-align:center;color:#888">(Ad placeholder)</p>
  </div>
</div>

<script>
/* ===== Geometry Dash OG Edition =====
   - Neon style, cube runner.
   - Space/up/click to jump. Start on first input.
   - Restart button resets cleanly.
   - Score = distance survived. High score saved to localStorage.
   - Difficulty ramps gently with distance.
*/

// Canvas setup
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const scoreEl = document.getElementById('score');
const highEl = document.getElementById('high');
const restartBtn = document.getElementById('restartBtn');

let highScore = Number(localStorage.getItem('gd_high') || 0);
highEl.textContent = highScore;

// Sounds (free pixabay small sounds)
const sJump = new Audio('https://cdn.pixabay.com/download/audio/2022/03/15/audio_1d16b16ab2.mp3?filename=flap-1.mp3');
const sHit  = new Audio('https://cdn.pixabay.com/download/audio/2021/09/07/audio_74261e1d35.mp3?filename=hit-1.mp3');
const sCheckpoint = new Audio('https://cdn.pixabay.com/download/audio/2021/08/09/audio_5f8c6a4f4d.mp3?filename=correct-2.mp3');

// Game state
let running = false;   // started by first input
let gameOver = false;
let frame = 0;
let distance = 0;

// Player
const player = {
  x: 110,
  y: H - 70,
  size: 36,
  vy: 0,
  gravity: 0.9,
  jumpPower: -14,
  grounded: true,
  color: '#00ff88',
  alive: true
};

// Ground and scroll
const groundY = H - 40;
let speed = 3; // base scroll speed

// Obstacles
let obstacles = [];

// Particles (neon trail)
let particles = [];

// Utility - rectangle collision
function rectsOverlap(a, b){
  return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
}

// Spawn obstacle
function spawnObstacle() {
  // obstacle shapes: tall block, double block (gap), spike group
  const type = Math.random() < 0.12 ? 'tall' : 'box'; // few tall
  const gap = Math.random() < 0.14; // occasional gap obstacle requiring double jump? We'll keep simple
  const baseW = 40 + Math.floor(Math.random()*30); // 40-70
  const baseH = (type === 'tall') ? 120 + Math.random()*80 : 40 + Math.random()*30;
  const obs = {
    x: W + 20,
    w: baseW,
    h: baseH,
    y: groundY - baseH,
    color: '#00ff88',
    passed: false
  };
  obstacles.push(obs);
}

// Reset game
function resetGame() {
  running = false;
  gameOver = false;
  frame = 0;
  distance = 0;
  speed = 3;
  obstacles = [];
  particles = [];
  player.y = H - 70;
  player.vy = 0;
  player.alive = true;
  player.grounded = true;
  scoreEl.textContent = '0';
  // draw initial frame
  draw();
}

// Input handlers
function jump() {
  if (!player.alive) return;
  if (!running) running = true; // first input starts run
  // allow jump when grounded or small coyote window (if near ground)
  if (player.grounded || player.vy > -2) {
    player.vy = player.jumpPower;
    player.grounded = false;
    sJump.currentTime = 0;
    sJump.play();
  }
}
document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    e.preventDefault();
    jump();
  }
});
canvas.addEventListener('mousedown', e => {
  jump();
});
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  jump();
}, {passive:false});

// Game update
function update() {
  frame++;

  // gentle difficulty ramp by distance
  if (distance > 2000) speed = 4.2;
  else if (distance > 1200) speed = 3.6;
  else if (distance > 600) speed = 3.2;

  // spawn obstacles at intervals that depend on speed and randomization
  if (running && frame % Math.max(60, Math.floor(140 - distance/60)) === 0) {
    // ensure peaceful early game: avoid obstacles for first 120 frames
    if (distance > 80 || Math.random() > 0.6) spawnObstacle();
  }

  // update obstacles
  for (let i = obstacles.length - 1; i >= 0; i--) {
    let o = obstacles[i];
    o.x -= speed;
    // mark passed and update score if it passes player
    if (!o.passed && o.x + o.w < player.x) {
      o.passed = true;
      // small checkpoint sound every 5 obstacles passed (approx)
      if (++distance % 15 === 0) { sCheckpoint.currentTime = 0; sCheckpoint.play(); }
    }
    // remove off-screen
    if (o.x + o.w < -50) obstacles.splice(i,1);
  }

  // physics on player
  if (running && player.alive) {
    player.vy += player.gravity * 0.6; // tuned gravity for smoother feel
    player.y += player.vy;

    // neon particle trail
    particles.push({x: player.x + player.size/2, y: player.y + player.size/2, life: 30 + Math.random()*10});
    if (particles.length > 180) particles.shift();

    // ground collision
    if (player.y + player.size >= groundY) {
      player.y = groundY - player.size;
      player.vy = 0;
      player.grounded = true;
    } else {
      player.grounded = false;
    }

    // collision detection with obstacles
    const pRect = {x: player.x, y: player.y, w: player.size, h: player.size};
    for (const o of obstacles) {
      const oRect = {x: o.x, y: o.y, w: o.w, h: o.h};
      if (rectsOverlap(pRect, oRect)) {
        // collision: end game
        player.alive = false;
        gameOver = true;
        sHit.currentTime = 0;
        sHit.play();
        // update best
        if (distance > highScore) {
          highScore = distance;
          localStorage.setItem('gd_high', highScore);
          highEl.textContent = highScore;
        }
      }
    }
  }
}

// Draw everything
function draw() {
  // background
  ctx.clearRect(0,0,W,H);
  // subtle parallax neon stripes
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#080808');
  g.addColorStop(1,'#0f0f10');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // decorative neon grid lines (parallax influenced by frame)
  ctx.save();
  ctx.globalAlpha = 0.08;
  ctx.strokeStyle = '#00ff99';
  ctx.lineWidth = 1;
  const offset = (frame * 0.2) % 40;
  for (let y = offset-40; y < H; y += 40) {
    ctx.beginPath();
    ctx.moveTo(0,y);
    ctx.lineTo(W,y);
    ctx.stroke();
  }
  ctx.restore();

  // draw ground
  ctx.fillStyle = '#0b0b0b';
  ctx.fillRect(0, groundY, W, H - groundY);
  // neon ground line
  ctx.fillStyle = 'rgba(0,255,136,0.06)';
  ctx.fillRect(0, groundY-6, W, 6);

  // draw obstacles (neon boxes)
  for (const o of obstacles) {
    // glow
    ctx.save();
    ctx.shadowColor = 'rgba(0,255,136,0.18)';
    ctx.shadowBlur = 18;
    ctx.fillStyle = 'rgba(0,255,136,0.95)';
    ctx.fillRect(o.x, o.y, o.w, o.h);
    ctx.restore();

    // inner darker
    ctx.fillStyle = '#003a21';
    ctx.fillRect(o.x+6, o.y+6, Math.max(1,o.w-12), Math.max(1,o.h-12));
  }

  // draw player (glowing cube)
  ctx.save();
  ctx.shadowColor = 'rgba(0,255,136,0.25)';
  ctx.shadowBlur = 22;
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.size, player.size);
  ctx.restore();

  // particles trail
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    ctx.fillStyle = `rgba(0,255,136,${Math.max(0, p.life/40)})`;
    ctx.fillRect(p.x - 3, p.y - 3, 6, 6);
    p.x -= speed * 0.28; // parallax drift
    p.life -= 1.2;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // HUD: distance
  ctx.fillStyle = 'rgba(0,255,136,0.06)';
  ctx.fillRect(8,8,120,34);
  ctx.fillStyle = '#00ffcc';
  ctx.font = '18px Poppins';
  ctx.fillText('Distance: ' + distance, 16, 32);

  // paused / start overlay
  if (!running && !gameOver) {
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#00ff88';
    ctx.font = '20px Poppins';
    ctx.fillText('Press Space / Click to Start', W/2 - 140, H/2);
  }

  // game over overlay
  if (gameOver) {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#00ff88';
    ctx.font = '28px Poppins';
    ctx.fillText('Game Over', W/2 - 70, H/2 - 10);
    ctx.font = '18px Poppins';
    ctx.fillText('Distance: ' + distance, W/2 - 56, H/2 + 22);
  }
}

// Main loop
function loop() {
  update();
  draw();
  // distance increases slowly while running and until gameOver
  if (running && player.alive) {
    distance = Math.floor(distance + speed * 0.6);
    scoreEl.textContent = distance;
  }
  if (!gameOver) requestAnimationFrame(loop);
}

// Restart button
restartBtn.addEventListener('click', () => {
  resetGame();
  // tiny delay then start loop to avoid accidental instant jump
  requestAnimationFrame(loop);
});

// Fun facts rotator
const funFacts = [
  'Geometry Dash is a rhythm-based platformer â€” timing is everything!',
  'Practice mode helps learn tricky sections without penalty.',
  'Neon visuals can help you focus on the rhythm of the level.',
  'Take short breaks â€” high concentration is key to long runs.',
  'Small, steady progress is better than rushing jumps.'
];
let factIdx = 0;
function rotateFunFact() {
  document.getElementById('funFact').textContent = funFacts[factIdx];
  factIdx = (factIdx + 1) % funFacts.length;
}
rotateFunFact();
setInterval(rotateFunFact, 9000);

// Initialize
resetGame();
draw();

// Start the animation after first input will set running=true automatically in jump()
requestAnimationFrame(loop);

</script>
</body>
</html>
